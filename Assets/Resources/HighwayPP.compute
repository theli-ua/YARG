#pragma kernel CSHighwayEffect

// Textures
Texture2D<float4> _SourceTexture;
Texture2D<float> _DepthTexture;
RWTexture2D<float4> _DestinationTexture;

// Samplers
SamplerState sampler_LinearClamp;

// Parameters
float4 _ZBufferParams;
float2 _FadeParams;
float _CurveFactor;
float _IsFading;
float4 _SourceTexture_TexelSize;

// Helper function to convert raw depth to linear eye depth
float LinearEyeDepth(float z, float4 zBufferParams)
{
    return 1.0 / (zBufferParams.z * z + zBufferParams.w);
}

[numthreads(8, 8, 1)]
void CSHighwayEffect(uint3 id : SV_DispatchThreadID)
{
    // Convert to UV space
    float2 uv = (id.xy + 0.5) * _SourceTexture_TexelSize.xy;
   
    // Sample color with displaced UV
    float4 color = _SourceTexture.SampleLevel(sampler_LinearClamp, uv, 0);
    
    // Sample depth
    float depth = _DepthTexture.SampleLevel(sampler_LinearClamp, uv, 0);
    float sceneEyeDepth = LinearEyeDepth(depth, _ZBufferParams);

    if (sceneEyeDepth >= _FadeParams.y)
        return;

    
    // Calculate alpha based on depth
    float rate = _FadeParams.y != _FadeParams.x ? 1.0 / (_FadeParams.y - _FadeParams.x) : 0.0;
    float alpha = smoothstep(0.0, 1.0, ((min(max(sceneEyeDepth, _FadeParams.x), _FadeParams.y)) - _FadeParams.x) * rate);
    
    // Apply alpha transformation
    color.a = color.a == 0.0 ? 0.0 : max(1.0 - _IsFading, min(color.a, 1.0 - alpha));

    // Calculate destination position with curve applied
    // Convert to centered coordinates (-0.5 to 0.5 of texture size)
    float2 centeredPos = (float2(id.xy) / float2(_SourceTexture_TexelSize.zw)) - 0.5;
    
    // Apply parabolic curve to Y based on X distance from center and depth
    // float curveAmount = _CurveFactor * sceneEyeDepth * 0.01; // Scale by depth
    float2 curvedPos = centeredPos;
    curvedPos.y -= (1.0 + sceneEyeDepth) * _CurveFactor * (centeredPos.x * centeredPos.x); // Parabolic curve
    
    // Convert back to pixel coordinates
    uint2 destPos = uint2((curvedPos + 0.5) * _SourceTexture_TexelSize.zw);
    id.y = destPos.y;
    
    // Make sure we're writing within bounds
    if (all(destPos < _SourceTexture_TexelSize.zw) && all(destPos >= 0))
    {
        // Write result to curved destination position
        _DestinationTexture[id.xy] = color;
    }
}
